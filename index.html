<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ver 0.0.35</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
      }
      .overlay {
        position: absolute;
        inset: 0;
        cursor: pointer;
        background: transparent; /* é€æ˜ï¼Œä½†æ¥ç®¡æ‰€æœ‰äº‹ä»¶ */
        /* å…è¨±å‚ç›´æ²å‹•ï¼›ç¸®æ”¾ä¸­æœƒæ”¹æˆ none */
        touch-action: pan-y;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        background: #000;
        overflow: hidden; /* ç¢ºä¿å¹³ç§»æ™‚ä¸æº¢å‡º */
      }
      /* å–®ä¸€åœ–ç‰‡ï¼Œç„¡ä»»ä½•æ·¡å…¥æ•ˆæœ */
      .slide {
        max-width: 100vw;
        max-height: 100vh;
        width: auto;
        height: auto;
        object-fit: contain; /* å®Œæ•´å‘ˆç¾ä¸è£åˆ‡ */
        background: #000;

        /* ç‚ºè‡ªè¨‚ç¸®æ”¾/å¹³ç§»åšå„ªåŒ– */
        will-change: transform;
        transform-origin: 0 0; /* ä»¥å·¦ä¸Šè§’ç‚ºåŸé»ï¼Œé…åˆ translate åšæº–ç¢ºå®šä½ */
      }
      .hint {
        position: fixed;
        left: 50%;
        bottom: 16px;
        transform: translateX(-50%);
        color: #fff;
        font: 14px/1.6 system-ui, "Microsoft JhengHei", sans-serif;
        opacity: 0.8;
        text-align: center;
        transition: opacity 0.3s ease;
      }
      .hint.hidden {
        opacity: 0;
        pointer-events: none;
      }

      /* å°Šé‡ä½¿ç”¨è€…æ¸›å°‘å‹•ç•«åå¥½ï¼ˆé€™è£¡åªå½±éŸ¿ hintï¼‰ */
      @media (prefers-reduced-motion: reduce) {
        .hint {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="stage" id="stage">
      <!-- âœ… å–®ä¸€ imgï¼Œé€é JS ç›´æ¥æ›´æ› src -->
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
      <div class="overlay" aria-hidden="true"></div>
    </div>

    <div class="hint" id="hint">
      â† â†’ éµåˆ‡æ›ï½œæ‰‹æ©Ÿå¯æ»‘å‹•æˆ–å·¦å³è¼•é»ï½œé›™æŒ‡å¯ç¸®æ”¾
    </div>

    <script>
      // ğŸ‘‰ è‹¥æª”åæ˜¯ 01.PNGã€02.PNG... ç”¨ padStart ç”Ÿæˆ
      const count = 12;
      const folder = "images/VermaVibe_20251217";

      // å¦‚æœä½ çš„æª”åæ˜¯ 1.PNG ~ 12.PNGï¼Œä½¿ç”¨ä¸‹æ–¹é€™æ®µï¼š
      const images = Array.from(
        { length: count },
        (_, i) => `${folder}/${String(i + 1)}.PNG`
      );

      let idx = 0;
      const viewer = document.getElementById("viewer");
      const stage = document.getElementById("stage");
      const hint = document.getElementById("hint");
      const overlay = document.querySelector(".overlay");

      // ====== è®Šå½¢ç‹€æ…‹ï¼ˆç¸®æ”¾ï¼å¹³ç§»ï¼‰======
      let scale = 1;
      const MIN_SCALE = 1;
      const MAX_SCALE = 6; // ä½ å¯èª¿æ•´ä¸Šé™
      let tx = 0; // translateX
      let ty = 0; // translateY

      // é›™æŒ‡ç¸®æ”¾æš«å­˜
      let p1 = null,
        p2 = null;
      let startDist = 0;
      let startScale = 1;
      let startMid = { x: 0, y: 0 };
      let startTx = 0,
        startTy = 0;

      // å–®æŒ‡æ‹–æ›³æš«å­˜
      let dragStart = null;

      // é›™æ“Šï¼ˆ/é›™æŒ‡é»æŒ‰ï¼‰åµæ¸¬
      let lastTap = 0;

      // å¥—ç”¨ç›®å‰çš„ç¸®æ”¾/å¹³ç§»åˆ° viewer
      function applyTransform() {
        viewer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      }

      // åœ¨ç¸®æ”¾ç‹€æ…‹ä¸‹ï¼Œé™åˆ¶å¹³ç§»é‚Šç•Œï¼Œé¿å…å®Œå…¨æ‹–å‡ºè¦–çª—
      function clampTranslate() {
        const rect = viewer.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();

        // åœ–ç‰‡åŸå§‹é¡¯ç¤ºå°ºå¯¸ï¼ˆobject-fit: containï¼‰ï¼Œç”¨ offset å¯¬é«˜è¿‘ä¼¼
        const imgW = viewer.offsetWidth;
        const imgH = viewer.offsetHeight;

        const contentW = imgW * scale;
        const contentH = imgH * scale;

        // ä»¥èˆå°ä¸­å¿ƒç‚ºå°é½ŠåŸºæº–ï¼ˆviewer èµ·å§‹åœ¨æ­£ä¸­é–“ï¼‰
        const stageW = stageRect.width;
        const stageH = stageRect.height;

        const maxOffsetX = Math.max(0, (contentW - stageW) / 2);
        const maxOffsetY = Math.max(0, (contentH - stageH) / 2);

        tx = Math.min(maxOffsetX, Math.max(-maxOffsetX, tx));
        ty = Math.min(maxOffsetY, Math.max(-maxOffsetY, ty));
      }

      function setTouchAction() {
        // ç¸®æ”¾ä¸­ç¦ç”¨ç€è¦½å™¨åŸç”Ÿæ²å‹•æ‰‹å‹¢ï¼ŒçµæŸç¸®æ”¾å›åˆ° pan-y
        overlay.style.touchAction = scale > 1 ? "none" : "pan-y";
      }

      function resetTransform() {
        scale = 1;
        tx = 0;
        ty = 0;
        applyTransform();
        setTouchAction();
      }

      function show(i) {
        idx = (i + images.length) % images.length;
        const url = images[idx];

        // ç¬¬ä¸€å¼µé¡¯ç¤ºæç¤ºï¼›ç¬¬äºŒå¼µé–‹å§‹éš±è—
        if (idx === 0) hint.classList.remove("hidden");
        else hint.classList.add("hidden");

        // åˆ‡æ›åœ–ç‰‡å‰å…ˆé‡ç½®ç¸®æ”¾/å¹³ç§»
        resetTransform();

        // ç›´æ¥åˆ‡æ›åœ–ç‰‡ï¼ˆç„¡æ·¡å…¥ï¼‰
        viewer.src = url;
        viewer.alt = `slide ${idx + 1}`;

        // å¢åŠ è¼‰å…¥å¤±æ•—çš„å›é€€ï¼ˆé¿å…å£é€£çµå¡ä½ï¼‰
        viewer.onerror = () => {
          console.warn("è¼‰å…¥å¤±æ•—ï¼š", url);
          hint.textContent = `è¼‰å…¥å¤±æ•—ï¼š${url}ï¼ˆé»æ“Šå¯è·³ä¸‹ä¸€å¼µï¼‰`;
          hint.classList.remove("hidden");
        };

        // é è¼‰ä¸‹ä¸€å¼µï¼Œæå‡åˆ‡æ›é †æš¢åº¦
        const pre = new Image();
        pre.src = images[(idx + 1) % images.length];
      }

      // ğŸ‘‰ å…±ç”¨çš„ã€Œä¾é»æ“Šä½ç½®ã€åˆ¤æ–·å‡½å¼ï¼ˆå·¦å³åŠé‚Šï¼‰
      function handlePositionalClick(clientX) {
        const { left, width } = stage.getBoundingClientRect();
        const x = clientX - left;
        const half = width / 2;
        if (x < half) {
          show(idx - 1); // å·¦åŠé‚Šï¼šä¸Šä¸€å¼µ
        } else {
          show(idx + 1); // å³åŠé‚Šï¼šä¸‹ä¸€å¼µ
        }
      }

      // å–æ¶ˆå³éµé¸å–®
      overlay.addEventListener("contextmenu", (e) => e.preventDefault());

      // ====== æŒ‡æ¨™äº‹ä»¶ï¼šç¸®æ”¾ï¼æ‹–æ›³ï¼åˆ‡æ› ======
      const activePointers = new Map();

      overlay.addEventListener("pointerdown", (e) => {
        // è¨˜éŒ„æŒ‡æ¨™
        activePointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });
        overlay.setPointerCapture(e.pointerId);

        // é›™æ“Šï¼ˆ300ms å…§ï¼‰
        const now = Date.now();
        if (now - lastTap < 300) {
          // ä»¥é»æ“Šä½ç½®ç‚ºä¸­å¿ƒåˆ‡æ› 1Ã— / 2Ã—
          const targetScale = scale > 1 ? 1 : 2;
          zoomAtPoint(targetScale, e.clientX, e.clientY);
          lastTap = 0;
          return;
        }
        lastTap = now;

        if (activePointers.size === 1) {
          // å–®æŒ‡ï¼šè‹¥å·²ç¸®æ”¾ï¼Œé€²å…¥æ‹–æ›³æ¨¡å¼
          if (scale > 1) {
            dragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
          }
        } else if (activePointers.size === 2) {
          // å…©æŒ‡ï¼šé–‹å§‹ pinch
          const pts = [...activePointers.values()];
          p1 = pts[0];
          p2 = pts[1];
          startDist = distance(p1, p2);
          startScale = scale;
          startMid = midpoint(p1, p2);
          startTx = tx;
          startTy = ty;
        }
      });

      overlay.addEventListener("pointermove", (e) => {
        if (!activePointers.has(e.pointerId)) return;
        activePointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });

        if (activePointers.size === 2) {
          // pinch é€²è¡Œä¸­
          const pts = [...activePointers.values()];
          const curDist = distance(pts[0], pts[1]);
          const mid = midpoint(pts[0], pts[1]);

          // æ–°ç¸®æ”¾
          let newScale = clamp(
            startScale * (curDist / startDist),
            MIN_SCALE,
            MAX_SCALE
          );

          // ä»¥ä¸­é»ç‚ºç¸®æ”¾ä¸­å¿ƒï¼šèª¿æ•´å¹³ç§»ï¼Œä½¿è¦–è¦ºä¸Šä¸­é»ä¸è·³å‹•
          const { x: mx, y: my } = mid;
          const { x: smx, y: smy } = startMid;
          // å…ˆå›åˆ°èµ·å§‹å¹³ç§»ï¼Œå†åŠ ä¸Šç‚ºäº†ç¸®æ”¾ä¸­å¿ƒé€ æˆçš„è£œå„Ÿ
          tx =
            startTx +
            (mx - smx) +
            (smx - stageCenter().x) * (newScale - startScale);
          ty =
            startTy +
            (my - smy) +
            (smy - stageCenter().y) * (newScale - startScale);

          scale = newScale;
          clampTranslate();
          applyTransform();
          setTouchAction();
        } else if (activePointers.size === 1 && dragStart && scale > 1) {
          // å–®æŒ‡æ‹–æ›³
          const cur = activePointers.get(e.pointerId);
          tx = dragStart.tx0 + (cur.x - dragStart.x);
          ty = dragStart.ty0 + (cur.y - dragStart.y);
          clampTranslate();
          applyTransform();
        }
      });

      overlay.addEventListener("pointerup", (e) => {
        activePointers.delete(e.pointerId);
        overlay.releasePointerCapture(e.pointerId);

        // æ‰‹æŒ‡/ç­†çµæŸæ™‚ï¼Œæ¸…ç†ç‹€æ…‹
        if (activePointers.size < 2) {
          p1 = p2 = null;
          startDist = 0;
        }
        if (activePointers.size === 0) {
          dragStart = null;
          // è‹¥æœªç¸®æ”¾ï¼Œæ‰åŸ·è¡Œå·¦å³åŠé‚Šé»æ“Šåˆ‡æ›
          if (scale === 1) {
            handlePositionalClick(e.clientX);
          }
        }
      });

      overlay.addEventListener("pointercancel", (e) => {
        activePointers.delete(e.pointerId);
        dragStart = null;
        p1 = p2 = null;
        startDist = 0;
      });

      // æ¡Œé¢ï¼šæ»‘é¼ æ»¾è¼ªç¸®æ”¾ï¼ˆCtrl+æ»¾è¼ªçš„åŸç”Ÿç¸®æ”¾é¿å…å¹²æ“¾ï¼‰
      stage.addEventListener(
        "wheel",
        (e) => {
          if (e.ctrlKey) return; // äº¤çµ¦ç€è¦½å™¨
          e.preventDefault();

          const delta = Math.sign(e.deltaY);
          const factor = delta > 0 ? 1 / 1.1 : 1.1;
          const targetScale = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
          zoomAtPoint(targetScale, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // éµç›¤ï¼šâ† å‰ä¸€å¼µï¼›â†’ ä¸‹ä¸€å¼µï¼›Home ç¬¬ä¸€å¼µï¼›End æœ€å¾Œä¸€å¼µï¼›ç©ºç™½éµä¸‹ä¸€å¼µ
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          show(idx - 1);
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          show(idx + 1);
        }
        if (e.key === "Home") {
          e.preventDefault();
          show(0);
        }
        if (e.key === "End") {
          e.preventDefault();
          show(images.length - 1);
        }
        if (e.key === " ") {
          e.preventDefault();
          show(idx + 1);
        }
        // å…¶ä»–å¿«æ·ï¼šR é‡ç½®ç¸®æ”¾ï¼›+/- èª¿æ•´ç¸®æ”¾
        if (e.key.toLowerCase() === "r") {
          e.preventDefault();
          resetTransform();
        }
        if (e.key === "+" || e.key === "=") {
          e.preventDefault();
          zoomAtPoint(
            clamp(scale * 1.1, MIN_SCALE, MAX_SCALE),
            stageCenter().x,
            stageCenter().y
          );
        }
        if (e.key === "-" || e.key === "_") {
          e.preventDefault();
          zoomAtPoint(
            clamp(scale / 1.1, MIN_SCALE, MAX_SCALE),
            stageCenter().x,
            stageCenter().y
          );
        }
      });

      // ====== ä¾¿åˆ©å‡½å¼ ======
      function distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }
      function midpoint(a, b) {
        return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      }
      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }
      function stageCenter() {
        const r = stage.getBoundingClientRect();
        return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
      }

      // ä»¥æŸä¸€é»ç‚ºä¸­å¿ƒç¸®æ”¾ï¼ˆæ”¯æ´é›™æ“Šèˆ‡æ»¾è¼ªï¼‰
      function zoomAtPoint(targetScale, clientX, clientY) {
        const prevScale = scale;
        targetScale = clamp(targetScale, MIN_SCALE, MAX_SCALE);

        // åœ¨è¦–çª—åº§æ¨™ç³»ä¸‹ï¼Œä»¥ clientX/Y ç‚ºä¸­å¿ƒèª¿æ•´å¹³ç§»
        const center = stageCenter();
        tx += (clientX - center.x) * (1 - targetScale / prevScale);
        ty += (clientY - center.y) * (1 - targetScale / prevScale);

        scale = targetScale;
        clampTranslate();
        applyTransform();
        setTouchAction();
      }

      // åˆå§‹åŒ–ï¼ˆé¡¯ç¤ºç¬¬ä¸€å¼µï¼›æç¤ºå¯è¦‹ï¼‰
      show(0);
    </script>
  </body>
</html>
