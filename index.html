<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ver 0.0.36</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
      }
      .overlay {
        position: absolute;
        inset: 0;
        cursor: pointer;
        background: transparent;
        /* æœªç¸®æ”¾æ™‚å…è¨±å‚ç›´æ²å‹• + åŸç”Ÿ pinch-zoomï¼›ç¸®æ”¾ä¸­æ”¹ç”± JS æ§åˆ¶ */
        touch-action: pan-y pinch-zoom;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        background: #000;
        overflow: hidden; /* å¹³ç§»æ™‚ä¸æº¢å‡º */
      }
      .slide {
        max-width: 100vw;
        max-height: 100vh;
        width: auto;
        height: auto;
        object-fit: contain;
        background: #000;

        will-change: transform;
        transform-origin: 0 0; /* ä»¥å·¦ä¸Šè§’ç‚ºåŸé»ï¼Œä¾¿æ–¼ translate + scale */
      }
      .hint {
        position: fixed;
        left: 50%;
        bottom: 16px;
        transform: translateX(-50%);
        color: #fff;
        font: 14px/1.6 system-ui, "Microsoft JhengHei", sans-serif;
        opacity: 0.8;
        text-align: center;
        transition: opacity 0.3s ease;
      }
      .hint.hidden {
        opacity: 0;
        pointer-events: none;
      }
      @media (prefers-reduced-motion: reduce) {
        .hint {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="stage" id="stage">
      <!-- âœ… å–®ä¸€ imgï¼Œé€é JS ç›´æ¥æ›´æ› src -->
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
      <div class="overlay" aria-hidden="true"></div>
    </div>

    <div class="hint" id="hint">
      â† â†’ éµåˆ‡æ›ï½œæ‰‹æ©Ÿå¯æ»‘å‹•æˆ–å·¦å³è¼•é»ï½œé›™æŒ‡å¯ç¸®æ”¾
    </div>

    <script>
      const count = 12;
      const folder = "images/VermaVibe_20251217";
      const images = Array.from(
        { length: count },
        (_, i) => `${folder}/${String(i + 1)}.PNG`
      );

      let idx = 0;
      const viewer = document.getElementById("viewer");
      const stage = document.getElementById("stage");
      const hint = document.getElementById("hint");
      const overlay = document.querySelector(".overlay");

      // ====== è®Šå½¢ç‹€æ…‹ï¼ˆç¸®æ”¾ï¼å¹³ç§»ï¼‰======
      let scale = 1;
      const MIN_SCALE = 1;
      const MAX_SCALE = 6;
      let tx = 0,
        ty = 0;

      // ä¾èˆå°èˆ‡åœ–ç‰‡æ¯”ä¾‹è¨ˆç®—ã€Œé¡¯ç¤ºå°ºå¯¸ï¼ˆcontain fitï¼‰ã€ï¼›é¿å…ç”¨ offsetWidth è¿‘ä¼¼
      function getDisplayedSize() {
        const stageRect = stage.getBoundingClientRect();
        const sw = stageRect.width,
          sh = stageRect.height;
        const nw = viewer.naturalWidth || viewer.width;
        const nh = viewer.naturalHeight || viewer.height;
        if (!nw || !nh || !sw || !sh) {
          // fallbackï¼šä»å¯é‹ä½œï¼Œä½†ç²¾åº¦è¼ƒä½
          return { w: viewer.offsetWidth, h: viewer.offsetHeight };
        }
        const imgRatio = nw / nh;
        const stageRatio = sw / sh;
        let w, h;
        if (imgRatio > stageRatio) {
          // ä»¥å¯¬ç‚ºä¸»
          w = sw;
          h = sw / imgRatio;
        } else {
          // ä»¥é«˜ç‚ºä¸»
          h = sh;
          w = sh * imgRatio;
        }
        return { w, h };
      }

      function applyTransform() {
        viewer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      }

      // ä»¥é¡¯ç¤ºå°ºå¯¸è¨ˆç®—å¹³ç§»é‚Šç•Œï¼Œç¢ºä¿èƒ½æ‹–åˆ°æœ€åº•éƒ¨
      function clampTranslate() {
        const stageRect = stage.getBoundingClientRect();
        const { w: dispW, h: dispH } = getDisplayedSize();

        const contentW = dispW * scale;
        const contentH = dispH * scale;

        const stageW = stageRect.width;
        const stageH = stageRect.height;

        // ä»¥èˆå°ä¸­å¿ƒå°é½Šï¼›èƒ½æ‹–åˆ°å››é‚Š
        const maxOffsetX = Math.max(0, (contentW - stageW) / 2);
        const maxOffsetY = Math.max(0, (contentH - stageH) / 2);

        tx = Math.min(maxOffsetX, Math.max(-maxOffsetX, tx));
        ty = Math.min(maxOffsetY, Math.max(-maxOffsetY, ty));
      }

      function setInteractionMode() {
        // æœªç¸®æ”¾ï¼šå…è¨±åŸç”Ÿ pinch-zoom èˆ‡å‚ç›´æ²å‹•ï¼›overlay æ¥ç®¡é»æ“Š
        if (scale === 1) {
          overlay.style.touchAction = "pan-y pinch-zoom";
          overlay.style.pointerEvents = "auto";
        } else {
          // ç¸®æ”¾ä¸­ï¼šäº¤çµ¦è‡ªè¨‚æ‹–æ›³ï¼›é¿å… overlay æ””æˆª
          overlay.style.touchAction = "none";
          overlay.style.pointerEvents = "none";
        }
      }

      function resetTransform() {
        scale = 1;
        tx = 0;
        ty = 0;
        applyTransform();
        setInteractionMode();
      }

      function show(i) {
        idx = (i + images.length) % images.length;
        const url = images[idx];

        if (idx === 0) hint.classList.remove("hidden");
        else hint.classList.add("hidden");

        resetTransform();

        viewer.src = url;
        viewer.alt = `slide ${idx + 1}`;
        viewer.onerror = () => {
          console.warn("è¼‰å…¥å¤±æ•—ï¼š", url);
          hint.textContent = `è¼‰å…¥å¤±æ•—ï¼š${url}ï¼ˆé»æ“Šå¯è·³ä¸‹ä¸€å¼µï¼‰`;
          hint.classList.remove("hidden");
        };
        // é è¼‰ä¸‹ä¸€å¼µ
        const pre = new Image();
        pre.src = images[(idx + 1) % images.length];
      }

      // ğŸ‘‰ å·¦å³åŠé‚Šåˆ‡æ›ï¼ˆåªåœ¨ç¸®æ”¾ï¼1 æ™‚ç”Ÿæ•ˆï¼‰
      function handlePositionalClick(clientX) {
        const { left, width } = stage.getBoundingClientRect();
        const x = clientX - left;
        const half = width / 2;
        if (x < half) show(idx - 1);
        else show(idx + 1);
      }

      // å–æ¶ˆå³éµé¸å–®
      overlay.addEventListener("contextmenu", (e) => e.preventDefault());

      // ====== åœ¨ viewer ä¸Šè™•ç†ç¸®æ”¾ï¼æ‹–æ›³ï¼é›™æ“Š ======
      const activePointers = new Map();
      let p1 = null,
        p2 = null;
      let startDist = 0,
        startScale = 1;
      let startMid = { x: 0, y: 0 };
      let startTx = 0,
        startTy = 0;
      let dragStart = null;
      let lastTap = 0;

      function stageCenter() {
        const r = stage.getBoundingClientRect();
        return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
      }
      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }
      function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      function midpoint(a, b) {
        return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      }

      // ä»¥æŸä¸€é»ç‚ºä¸­å¿ƒç¸®æ”¾ï¼ˆæ”¯æ´é›™æ“Šèˆ‡æ»¾è¼ªï¼‰
      function zoomAtPoint(targetScale, clientX, clientY) {
        const prevScale = scale;
        targetScale = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const center = stageCenter();

        // ä»¥æ¸¸æ¨™/è§¸é»ç›¸å°èˆå°ä¸­å¿ƒç‚ºåŸºæº–ï¼Œè£œå„Ÿå¹³ç§»
        tx += (clientX - center.x) * (1 - targetScale / prevScale);
        ty += (clientY - center.y) * (1 - targetScale / prevScale);

        scale = targetScale;
        clampTranslate();
        applyTransform();
        setInteractionMode();
      }

      // æŒ‡æ¨™äº‹ä»¶æ›åœ¨ viewerï¼ˆä¸æ˜¯ overlayï¼‰
      viewer.addEventListener("pointerdown", (e) => {
        activePointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });
        viewer.setPointerCapture(e.pointerId);

        // é›™æ“Šï¼ˆ300ms å…§ï¼‰
        const now = Date.now();
        if (now - lastTap < 300) {
          const targetScale = scale > 1 ? 1 : 2;
          zoomAtPoint(targetScale, e.clientX, e.clientY);
          lastTap = 0;
          return;
        }
        lastTap = now;

        if (activePointers.size === 1) {
          // æœªç¸®æ”¾ï¼šè®“ overlay è™•ç†å·¦å³åŠé‚Šé»æ“Šï¼›ç¸®æ”¾ä¸­ï¼šå–®æŒ‡æ‹–æ›³
          if (scale > 1)
            dragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
        } else if (activePointers.size === 2) {
          const pts = [...activePointers.values()];
          p1 = pts[0];
          p2 = pts[1];
          startDist = distance(p1, p2);
          startScale = scale;
          startMid = midpoint(p1, p2);
          startTx = tx;
          startTy = ty;
          // é€²å…¥ç¸®æ”¾æ¨¡å¼ï¼šé—œé–‰ overlay äº‹ä»¶
          setInteractionMode();
        }
      });

      viewer.addEventListener("pointermove", (e) => {
        if (!activePointers.has(e.pointerId)) return;
        activePointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });

        if (activePointers.size === 2) {
          const pts = [...activePointers.values()];
          const curDist = distance(pts[0], pts[1]);
          const mid = midpoint(pts[0], pts[1]);

          let newScale = clamp(
            startScale * (curDist / startDist),
            MIN_SCALE,
            MAX_SCALE
          );

          const { x: mx, y: my } = mid;
          const { x: smx, y: smy } = startMid;
          tx =
            startTx +
            (mx - smx) +
            (smx - stageCenter().x) * (newScale - startScale);
          ty =
            startTy +
            (my - smy) +
            (smy - stageCenter().y) * (newScale - startScale);

          scale = newScale;
          clampTranslate();
          applyTransform();
          setInteractionMode();
        } else if (activePointers.size === 1 && dragStart && scale > 1) {
          const cur = activePointers.get(e.pointerId);
          tx = dragStart.tx0 + (cur.x - dragStart.x);
          ty = dragStart.ty0 + (cur.y - dragStart.y);
          clampTranslate();
          applyTransform();
        }
      });

      viewer.addEventListener("pointerup", (e) => {
        activePointers.delete(e.pointerId);
        viewer.releasePointerCapture(e.pointerId);

        if (activePointers.size < 2) {
          p1 = p2 = null;
          startDist = 0;
        }
        if (activePointers.size === 0) {
          dragStart = null;
          // æœªç¸®æ”¾æ™‚ï¼šäº¤é‚„ overlay ä¾†è™•ç†å·¦å³åŠé‚Šé»æ“Š
          setInteractionMode();
        }
      });

      viewer.addEventListener("pointercancel", (e) => {
        activePointers.delete(e.pointerId);
        dragStart = null;
        p1 = p2 = null;
        startDist = 0;
        setInteractionMode();
      });

      // æ¡Œé¢ï¼šæ»‘é¼ æ»¾è¼ªç¸®æ”¾ï¼ˆä»¥æ¸¸æ¨™ç‚ºä¸­å¿ƒï¼‰
      stage.addEventListener(
        "wheel",
        (e) => {
          if (e.ctrlKey) return; // äº¤çµ¦ç€è¦½å™¨çš„æ•´é ç¸®æ”¾
          e.preventDefault();
          const delta = Math.sign(e.deltaY);
          const factor = delta > 0 ? 1 / 1.1 : 1.1;
          const targetScale = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
          zoomAtPoint(targetScale, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // overlay åªç®¡ã€Œå·¦å³åŠé‚Šåˆ‡æ›ã€ï¼ˆä¸”åªåœ¨ç¸®æ”¾ï¼1æ™‚æœ‰ pointerEventsï¼‰
      overlay.addEventListener("pointerup", (e) => {
        if (scale === 1) handlePositionalClick(e.clientX);
      });

      // éµç›¤ï¼šâ† â†’ã€Homeã€Endã€ç©ºç™½ï¼›é¡å¤–ï¼šR é‡ç½®ã€+/- ä¸­å¿ƒç¸®æ”¾
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          show(idx - 1);
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          show(idx + 1);
        }
        if (e.key === "Home") {
          e.preventDefault();
          show(0);
        }
        if (e.key === "End") {
          e.preventDefault();
          show(images.length - 1);
        }
        if (e.key === " ") {
          e.preventDefault();
          show(idx + 1);
        }
        if (e.key.toLowerCase() === "r") {
          e.preventDefault();
          resetTransform();
        }
        if (e.key === "+" || e.key === "=") {
          e.preventDefault();
          const c = stageCenter();
          zoomAtPoint(clamp(scale * 1.1, MIN_SCALE, MAX_SCALE), c.x, c.y);
        }
        if (e.key === "-" || e.key === "_") {
          e.preventDefault();
          const c = stageCenter();
          zoomAtPoint(clamp(scale / 1.1, MIN_SCALE, MAX_SCALE), c.x, c.y);
        }
      });

      // åˆå§‹åŒ–
      show(0);
    </script>
  </body>
</html>
