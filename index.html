<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <!-- ä½¿ç”¨ viewport-fit=cover + dvh ä»¥æå‡ç›´ç«‹å¼å¯è¦–é«˜åº¦ç²¾æº–åº¦ -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Ver 0.0.55</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overscroll-behavior: contain;
      }
      .stage {
        position: fixed;
        inset: 0;
        height: 100dvh; /* å‹•æ…‹è¦–çª—é«˜åº¦ï¼Œé¿å…æ‰‹æ©Ÿç›´ç«‹æ™‚ 100vh å·¥å…·åˆ—èª¤å·® */
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        background: #000;
        overflow: hidden;
        touch-action: pan-y pinch-zoom; /* ç¸®æ”¾ä¸­æœƒæ”¹ç‚º none */
      }
      .slide {
        max-width: 100vw;
        max-height: 100dvh;
        width: auto;
        height: auto;
        object-fit: contain;
        background: #000;
        will-change: transform;
        transform-origin: 0 0;
        position: relative;
        z-index: 1;
        /* æœªç¸®æ”¾å…è¨±åŸç”Ÿæåˆ/å‚ç›´æ²å‹•ï¼›ç¸®æ”¾æ™‚ç”± JS æ”¹ç‚º none */
        touch-action: pan-y pinch-zoom;
        backface-visibility: hidden;
        translate: 0 0;
      }
      .hint {
        position: fixed;
        left: 50%;
        bottom: 16px;
        transform: translateX(-50%);
        color: #fff;
        font: 14px/1.6 system-ui, "Microsoft JhengHei", sans-serif;
        opacity: 0.8;
        text-align: center;
        transition: opacity 0.3s ease;
      }
      .hint.hidden {
        opacity: 0;
        pointer-events: none;
      }
      @media (prefers-reduced-motion: reduce) {
        .hint {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="stage" id="stage">
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
    </div>

    <div class="hint" id="hint">
      â† â†’ éµåˆ‡æ›ï½œæ‰‹æ©Ÿå–®æ“Šæˆ–æ»‘å‹•å¯åˆ‡æ›ï½œé›™æŒ‡å¯ç¸®æ”¾
    </div>

    <script>
      // ===== è¨­å®š =====
      const count = 12;
      const folder = "images/VermaVibe_20251217";
      const images = Array.from(
        { length: count },
        (_, i) => `${folder}/${String(i + 1)}.PNG`
      );

      const MIN_SCALE = 1,
        MAX_SCALE = 6;
      const DOUBLE_TAP_MS = 300,
        WHEEL_ZOOM_FACTOR = 1.1;
      const PAN_SPEED_BASE = 1.6,
        EPS = 0.5;

      const isTouchDevice = navigator.maxTouchPoints > 0;

      // ğŸ”§ æ–°å¢ï¼šç¸®æ”¾éŒ¨é» & æ»¾è¼ªå¹³ç§»é–‹é—œï¼ˆæ»¿è¶³ã€Œä¸è¦è·Ÿè‘—æ¸¸æ¨™ç§»å‹•ã€ï¼‰
      const ZOOM_ANCHOR = "center"; // 'center' | 'pointer'ï¼ˆé è¨­ centerï¼Œä¸è·Ÿè‘—æ¸¸æ¨™ï¼‰
      const ENABLE_WHEEL_PAN = false; // é è¨­é—œé–‰æ»¾è¼ªå¹³ç§»

      // Tap é–¾å€¼ï¼ˆæ‰‹æ©Ÿè¼ƒå¯¬é¬†ï¼‰
      const CLICK_THRESHOLD_PX = isTouchDevice ? 22 : 10;
      const CLICK_THRESHOLD_PY = isTouchDevice ? 22 : 10;
      const TAP_DURATION_MS = 250;

      // Swipe é–¾å€¼ï¼ˆè·é›¢ + é€Ÿåº¦ï¼‰
      const SWIPE_MIN_PX = isTouchDevice ? 48 : 36;
      const SWIPE_MIN_VELOCITY = 0.35; // px/ms

      // ===== DOM =====
      const viewer = document.getElementById("viewer");
      const stage = document.getElementById("stage");
      const hint = document.getElementById("hint");

      // ===== ç‹€æ…‹ =====
      let idx = 0;
      let scale = 1;
      let tx = 0,
        ty = 0;
      let rafId = null,
        lastTap = 0;

      const pointers = new Map();
      let dragStart = null; // viewer æ‹–æ›³ç”¨
      let stageDragStart = null; // stage æ‹–æ›³ç”¨ï¼ˆscale>1 æ™‚å•Ÿç”¨ï¼‰

      let touchDragStart = null;
      let touchStartDist = 0;
      let touchStartScale = 1;
      let touchAnchorP = { x: 0, y: 0 };

      let baseW = 0,
        baseH = 0;

      // Tap / Swipeï¼ˆåƒ… scale===1 æ™‚å•Ÿç”¨ï¼‰
      let tapStartX = null,
        tapStartY = null,
        tapStartTime = 0;
      let lastMoveX = null,
        lastMoveY = null,
        lastMoveTime = 0;

      // ===== å·¥å…· =====
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const distance = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const midpoint = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });

      function stageRect() {
        return stage.getBoundingClientRect();
      }
      function stageSize() {
        const vv = window.visualViewport;
        if (vv && vv.width && vv.height)
          return { width: vv.width, height: vv.height };
        const r = stageRect();
        return { width: r.width, height: r.height };
      }
      function imageTopLeftLocal() {
        const { width: stageW, height: stageH } = stageSize();
        return { x: (stageW - baseW) / 2, y: (stageH - baseH) / 2 };
      }
      function clientToImagePoint(clientX, clientY) {
        const L = imageTopLeftLocal();
        const ix = (clientX - L.x - tx) / scale;
        const iy = (clientY - L.y - ty) / scale;
        return { x: clamp(ix, 0, baseW), y: clamp(iy, 0, baseH) };
      }
      function fitContain(sw, sh, nw, nh) {
        const imgRatio = nw / nh,
          stageRatio = sw / sh;
        if (imgRatio > stageRatio) return { w: sw, h: sw / imgRatio };
        return { h: sh, w: sh * imgRatio };
      }
      function recomputeBaseSize() {
        const { width: sw, height: sh } = stageSize();
        const nw = viewer.naturalWidth || viewer.width || viewer.offsetWidth;
        const nh = viewer.naturalHeight || viewer.height || viewer.offsetHeight;
        if (!nw || !nh || !sw || !sh) return;
        const s = fitContain(sw, sh, nw, nh);
        baseW = s.w;
        baseH = s.h;
        commit(true);
      }

      // ===== è¦–è¦ºæ›´æ–° =====
      function commit(needsClamp = true) {
        if (needsClamp) clampTranslate();
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
          viewer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
          setInteractionMode();
          rafId = null;
        });
      }

      function clampTranslate() {
        const { width: stageW, height: stageH } = stageSize();
        const L = imageTopLeftLocal(); // å±…ä¸­å¾Œçš„æœ¬åœ°å·¦ä¸Šè§’
        const contentW = baseW * scale;
        const contentH = baseH * scale;

        // æ°´å¹³
        if (contentW > stageW) {
          const minTx = stageW - L.x - contentW - EPS; // å³è²¼é½Š
          const maxTx = -L.x + EPS; // å·¦è²¼é½Š
          tx = clamp(tx, minTx, maxTx);
        } else {
          tx = 0;
        }
        // å‚ç›´
        if (contentH > stageH) {
          const minTy = stageH - L.y - contentH - EPS; // åº•è²¼é½Š
          const maxTy = -L.y + EPS; // é ‚è²¼é½Š
          ty = clamp(ty, minTy, maxTy);
        } else {
          ty = 0;
        }
      }

      function setInteractionMode() {
        if (scale === 1) {
          viewer.style.touchAction = "pan-y pinch-zoom";
          stage.style.touchAction = "pan-y pinch-zoom";
        } else {
          viewer.style.touchAction = "none";
          stage.style.touchAction = "none";
        }
      }

      function resetTransform() {
        scale = 1;
        tx = 0;
        ty = 0;
        commit();
      }

      // ===== é¡¯ç¤ºåœ–ç‰‡ =====
      function show(i) {
        idx = (i + images.length) % images.length;
        const url = images[idx];

        hint.classList.toggle("hidden", idx !== 0);
        resetTransform();

        viewer.src = url;
        viewer.alt = `slide ${idx + 1}`;
        viewer.onload = () => {
          recomputeBaseSize();
        };
        viewer.onerror = () => {
          hint.textContent = `è¼‰å…¥å¤±æ•—ï¼š${url}ï¼ˆé»æ“Šå¯è·³ä¸‹ä¸€å¼µï¼‰`;
          hint.classList.remove("hidden");
        };

        // é è¼‰ä¸‹ä¸€å¼µ
        const pre = new Image();
        pre.src = images[(idx + 1) % images.length];
      }

      // å·¦å³åŠé‚Šæ›é ï¼ˆåƒ… scale===1 æ™‚ï¼‰
      function handlePositionalClick(clientX) {
        if (scale !== 1) return;
        const { width: stageW } = stageSize();
        const leftHalf = clientX < stageW / 2;
        show(leftHalf ? idx - 1 : idx + 1);
      }

      // ä»¥åœ–ç‰‡åº§æ¨™ç‚ºä¸­å¿ƒç¸®æ”¾ï¼ˆèˆå°æœ¬åœ°ï¼‰
      function zoomAtImagePoint(targetScale, clientX, clientY) {
        const s1 = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const L = imageTopLeftLocal();
        const p = clientToImagePoint(clientX, clientY);
        tx = clientX - L.x - p.x * s1;
        ty = clientY - L.y - p.y * s1;
        scale = s1;
        commit(true);
      }

      // ğŸ”§ æ–°å¢ï¼šä»¥ä¸­å¿ƒç¸®æ”¾ï¼ˆä¸è·Ÿæ¸¸æ¨™ï¼‰
      function zoomAtCenter(targetScale) {
        const { width: stageW, height: stageH } = stageSize();
        const cX = stageW / 2,
          cY = stageH / 2;
        zoomAtImagePoint(targetScale, cX, cY);
      }

      // ===== Viewerï¼šPointerï¼ˆåªè² è²¬ç¸®æ”¾/æ‹–æ›³ï¼‰=====
      viewer.addEventListener("pointerdown", (e) => {
        pointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });
        if (scale > 1) {
          try {
            viewer.setPointerCapture(e.pointerId);
          } catch {}
        } else if (e.pointerType !== "touch") {
          try {
            viewer.setPointerCapture(e.pointerId);
          } catch {}
        }

        const now = Date.now();
        if (now - lastTap < DOUBLE_TAP_MS) {
          // é›™æ“Šï¼šæœªç¸®æ”¾ -> ä¸­å¿ƒæ”¾å¤§ï¼›å·²ç¸®æ”¾ -> ä¸­å¿ƒé‚„åŸ
          if (scale > 1) zoomAtCenter(1);
          else zoomAtCenter(2);
          lastTap = 0;
          return;
        }
        lastTap = now;

        if (pointers.size === 1) {
          if (scale > 1) {
            const p = pointers.get(e.pointerId);
            dragStart = { x: p.x, y: p.y, tx0: tx, ty0: ty };
          }
        } else if (pointers.size === 2) {
          const pts = [...pointers.values()];
          const mid = midpoint(pts[0], pts[1]);
          touchAnchorP = clientToImagePoint(mid.x, mid.y);
        }
      });

      viewer.addEventListener("pointermove", (e) => {
        if (!pointers.has(e.pointerId)) return;
        pointers.set(e.pointerId, {
          x: e.clientX,
          y: e.clientY,
          type: e.pointerType,
        });

        if (pointers.size === 2) {
          const pts = [...pointers.values()];
          const curDist = distance(pts[0], pts[1]);
          const prevDist = viewer._prevDist ?? curDist;
          viewer._prevDist = curDist;

          const s1 = clamp(
            scale * (curDist / prevDist || 1),
            MIN_SCALE,
            MAX_SCALE
          );

          const mid = midpoint(pts[0], pts[1]);
          const L = imageTopLeftLocal();
          tx = mid.x - L.x - touchAnchorP.x * s1;
          ty = mid.y - L.y - touchAnchorP.y * s1;

          scale = s1;
          commit(true);
        } else if (pointers.size === 1 && dragStart && scale > 1) {
          const cur = pointers.get(e.pointerId);
          tx = dragStart.tx0 + (cur.x - dragStart.x);
          ty = dragStart.ty0 + (cur.y - dragStart.y);
          commit(true);
        }
      });

      viewer.addEventListener("pointerup", (e) => {
        pointers.delete(e.pointerId);
        try {
          viewer.releasePointerCapture(e.pointerId);
        } catch {}
        if (pointers.size === 0) {
          dragStart = null;
          viewer._prevDist = undefined;
          setInteractionMode();
        }
      });

      viewer.addEventListener("pointercancel", () => {
        pointers.clear();
        dragStart = null;
        viewer._prevDist = undefined;
        setInteractionMode();
      });

      // ===== Stageï¼šTap + Swipeï¼ˆscale===1ï¼‰ï¼ŒDragï¼ˆscale>1ï¼‰=====
      stage.addEventListener("pointerdown", (e) => {
        if (scale > 1) {
          stageDragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
          try {
            stage.setPointerCapture(e.pointerId);
          } catch {}
          return;
        }
        if (e.buttons && e.buttons !== 1) return; // åƒ…ä¸»éµ/è§¸æ§
        tapStartX = e.clientX;
        tapStartY = e.clientY;
        tapStartTime = performance.now();
        lastMoveX = tapStartX;
        lastMoveY = tapStartY;
        lastMoveTime = tapStartTime;
      });

      stage.addEventListener("pointermove", (e) => {
        if (scale > 1 && stageDragStart) {
          tx = stageDragStart.tx0 + (e.clientX - stageDragStart.x);
          ty = stageDragStart.ty0 + (e.clientY - stageDragStart.y);
          commit(true);
          return;
        }
        lastMoveX = e.clientX;
        lastMoveY = e.clientY;
        lastMoveTime = performance.now();
      });

      stage.addEventListener("pointerup", (e) => {
        if (scale > 1) {
          stageDragStart = null;
          try {
            stage.releasePointerCapture(e.pointerId);
          } catch {}
          return;
        }

        const endX = e.clientX,
          endY = e.clientY;
        const endTime = performance.now();
        const dx = endX - (tapStartX ?? endX);
        const dy = endY - (tapStartY ?? endY);
        const dt = endTime - (tapStartTime || endTime);

        const mvDt = Math.max(1, endTime - (lastMoveTime || endTime));
        const mvDx = endX - (lastMoveX ?? endX);
        const velocityX = Math.abs(mvDx) / mvDt; // px/ms

        const absDx = Math.abs(dx),
          absDy = Math.abs(dy);
        const isSwipe =
          absDx > SWIPE_MIN_PX &&
          absDx > absDy * 1.5 &&
          velocityX >= SWIPE_MIN_VELOCITY;

        if (isSwipe) {
          show(dx < 0 ? idx + 1 : idx - 1);
        } else {
          if (
            absDx <= CLICK_THRESHOLD_PX &&
            absDy <= CLICK_THRESHOLD_PY &&
            dt <= TAP_DURATION_MS
          ) {
            handlePositionalClick(endX);
          }
        }

        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
      });

      stage.addEventListener("pointercancel", () => {
        stageDragStart = null;
        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
      });

      stage.addEventListener("contextmenu", (e) => e.preventDefault());

      // ===== æ‰‹æ©Ÿ Touch Fallbackï¼šstage ä¹Ÿèƒ½æ‹–æ›³ï¼ˆscale>1ï¼‰=====
      if (isTouchDevice) {
        stage.addEventListener(
          "touchstart",
          (e) => {
            if (scale > 1 && e.touches.length === 1) {
              const t = e.touches[0];
              stageDragStart = { x: t.clientX, y: t.clientY, tx0: tx, ty0: ty };
              stage.style.touchAction = "none";
            }
          },
          { passive: true }
        );

        stage.addEventListener(
          "touchmove",
          (e) => {
            if (scale > 1 && e.touches.length === 1 && stageDragStart) {
              e.preventDefault();
              const t = e.touches[0];
              tx = stageDragStart.tx0 + (t.clientX - stageDragStart.x);
              ty = stageDragStart.ty0 + (t.clientY - stageDragStart.y);
              commit(true);
            }
          },
          { passive: false }
        );

        stage.addEventListener(
          "touchend",
          (e) => {
            if (e.touches.length === 0) {
              stageDragStart = null;
              setInteractionMode();
            }
          },
          { passive: true }
        );

        stage.addEventListener(
          "touchcancel",
          () => {
            stageDragStart = null;
            setInteractionMode();
          },
          { passive: true }
        );
      }

      // ===== æ»¾è¼ªï¼ˆç¸®æ”¾ï¼å¹³ç§»ï¼‰=====
      function normalizeMagnitude(e) {
        let dx = e.deltaX,
          dy = e.deltaY;
        const LINE = 40,
          PAGE = Math.max(window.innerHeight, 600);
        if (e.deltaMode === 1) {
          dx *= LINE;
          dy *= LINE;
        } else if (e.deltaMode === 2) {
          dx *= PAGE;
          dy *= PAGE;
        }
        return Math.max(Math.abs(dx), Math.abs(dy));
      }
      function panGain(m) {
        return 1 + 2.5 * Math.tanh(m / 180);
      }
      function getPanSpeed(e) {
        return PAN_SPEED_BASE * panGain(normalizeMagnitude(e));
      }

      const onWheel = (e) => {
        // Ctrl+æ»¾è¼ªï¼šç¸®æ”¾ï¼ˆé è¨­ä»¥ä¸­å¿ƒç‚ºéŒ¨é»ï¼Œä¸è·Ÿæ¸¸æ¨™ï¼‰
        if (e.ctrlKey) {
          e.preventDefault();
          const factor =
            Math.sign(e.deltaY) > 0 ? 1 / WHEEL_ZOOM_FACTOR : WHEEL_ZOOM_FACTOR;
          const target = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
          if (ZOOM_ANCHOR === "center") {
            zoomAtCenter(target);
          } else {
            zoomAtImagePoint(target, e.clientX, e.clientY);
          }
          return;
        }
        // æ»¾è¼ªå¹³ç§»ï¼šé è¨­é—œé–‰ï¼ˆé¿å…ç•«é¢è·Ÿè‘—æ¸¸æ¨™ç§»å‹•ï¼‰
        if (scale > 1 && ENABLE_WHEEL_PAN) {
          e.preventDefault();
          const speed = getPanSpeed(e);
          tx -= e.deltaX * speed;
          ty -= e.deltaY * speed;
          commit(true);
        }
      };
      stage.addEventListener("wheel", onWheel, { passive: false });
      viewer.addEventListener("wheel", onWheel, { passive: false });

      // ===== éµç›¤ =====
      document.addEventListener("keydown", (e) => {
        const key = e.key;
        if (key === "ArrowLeft") {
          e.preventDefault();
          show(idx - 1);
        } else if (key === "ArrowRight") {
          e.preventDefault();
          show(idx + 1);
        } else if (key === "Home") {
          e.preventDefault();
          show(0);
        } else if (key === "End") {
          e.preventDefault();
          show(images.length - 1);
        } else if (key === " ") {
          e.preventDefault();
          show(idx + 1);
        } else if (key.toLowerCase() === "r") {
          e.preventDefault();
          resetTransform();
        } else if (key === "+" || key === "=") {
          e.preventDefault();
          zoomAtCenter(clamp(scale * WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        } else if (key === "-" || key === "_") {
          e.preventDefault();
          zoomAtCenter(clamp(scale / WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        }
      });

      // ===== èˆå°å°ºå¯¸è®Šæ›´ =====
      function recomputeOnViewportChange() {
        recomputeBaseSize();
      }
      window.addEventListener("resize", recomputeOnViewportChange);
      if (window.visualViewport) {
        window.visualViewport.addEventListener(
          "resize",
          recomputeOnViewportChange
        );
      }
      window.addEventListener("orientationchange", recomputeOnViewportChange);

      // ===== åˆå§‹åŒ– =====
      show(0);
    </script>
  </body>
</html>
